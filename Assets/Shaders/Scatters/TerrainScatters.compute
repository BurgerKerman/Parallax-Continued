
// Noise modes        - Kernels 0, 1, 2
// Base kernel defaults to perlin
#pragma kernel Distribute
#pragma kernel Distribute NOISEMODE_CELLULAR
#pragma kernel Distribute NOISEMODE_POLKADOT

// Render             - Kernel 3
#pragma kernel Evaluate

#include "ScatterStructs.cginc"
#include "ScatterParams.cginc"
#include "../Includes/gpu_noise_lib.glsl"
#include "ScatterUtils.cginc"

StructuredBuffer<int> triangles;
StructuredBuffer<float3> vertices;
StructuredBuffer<float3> normals;

// UV in xy, allowScatter in z
StructuredBuffer<float3> uvs;

// Normalized directions from planet center to quad vertex
StructuredBuffer<float3> directionsFromCenter;

// Biome map - RGBA (although alpha is unused, I can't convert to RGB)
Texture2D<float4> biomeMap;
Texture2D<float4> scatterBiomes;

// The naming is important here
SamplerState linearClampSampler;
SamplerState pointClampSampler;

AppendStructuredBuffer<PositionData> output;

//
//  Distribution Compute Shader
//

// Runs per triangle in the mesh (indices count / 3)

[numthreads(32,1,1)]
void Distribute (uint3 id : SV_DispatchThreadID)
{
    // Early return if max triangles to be processed is exceeded
    if (((int)id.x * _PopulationMultiplier) > _MaxCount - 1)
    {
        return;
    }
    
    // Get the indices for the vertices of this thread's triangle
    uint index1 = triangles[id.x * 3];
    uint index2 = triangles[id.x * 3 + 1];
    uint index3 = triangles[id.x * 3 + 2];
    
    // Get triangle vertices
    float3 v1 = vertices[index1];
    float3 v2 = vertices[index2];
    float3 v3 = vertices[index3];
    
    // Get triangle UVs
    float3 uv1 = uvs[index1];
    float3 uv2 = uvs[index2];
    float3 uv3 = uvs[index3];
    
    // Get triangle normals
    float3 n1 = normals[index1];
    float3 n2 = normals[index2];
    float3 n3 = normals[index3];
    
    float3 averageNormal = TriCenter(n1, n2, n3);
    
    // Get face center UV
    float3 centerUV = (uv1 + uv2 + uv3) * 0.333f;
    float vertexAllowScatter = centerUV.z;
    
    // Get the biome colour
    float3 biome = biomeMap.SampleLevel(pointClampSampler, centerUV.xy, 0).rgb;
    
    // Does this biome colour match any of the biomes this scatter can appear in?
    int biomesEligible = 0;
    for (int b = 0; b < _NumberOfBiomes; b++)
    {
        float3 biomeColor = scatterBiomes.SampleLevel(pointClampSampler, float2(0, (float)b / (float)_NumberOfBiomes), 0).rgb;
        biomesEligible += BiomeEligible(biome, biomeColor);
    }
    
    // Skip this triangle if this scatter isn't eligible on it
    if (biomesEligible == 0)
    {
        return;
    }
    
    // Don't place scatters on ineligible gradients, such as mountains
    float slope = CalculateSlope(averageNormal);
    if (slope < 0.025)
    {
        slope = 0;
    }
    
    // If the mesh is too curved, we can end up with scatters floating/overhanging the terrain (depending on scatter mesh and size)
    // So skip this triangle entirely
    float normalDeviance = GetNormalDeviance(n1, n2, n3);
    if (normalDeviance < 1.0f - _MaxNormalDeviance)
    {
        return;
    }
    
    // Get direction from center
    float3 dfc1 = directionsFromCenter[index1];
    float3 dfc2 = directionsFromCenter[index2];
    float3 dfc3 = directionsFromCenter[index3];
    
    // Use UV and id as random seed. It's not elegant, but it's persistent. Fyi, using the quad local position triangle center is not valid here
    // This produces sufficient randomness
    float3 randomSeed = float3(centerUV.xy + _Seed, id.x);
    
    // Create an object on this triangle for every population multiplier
    for (int i = 0; i < _PopulationMultiplier; i++)
    {
        // Output struct
        PositionData newObject;
        
        // Get decently random numbers
        float random1 = Rand(randomSeed + i);
        float random2 = Rand(randomSeed - i);
        float random3 = Rand(randomSeed * 0.5 + i);
        float random4 = Rand(randomSeed * 0.5 - i);
        float random5 = Rand(randomSeed * 0.25 + i);
        
        // X must be sqrtd to achieve a uniform distribution
        float randomX = sqrt(random1);
        float randomY = random2;
        float3 localPos = RandomPoint(v1, v2, v3, randomX, randomY);
        float3 localCenterDir = RandomPoint(dfc1, dfc2, dfc3, randomX, randomY);
        float3 localNormal = RandomPoint(dfc1, dfc2, dfc3, randomX, randomY);
        
        float noise = Noise(localCenterDir);
        
        // Do we blend between min and max scale based on the noise value, randomly, or a mix of both?
        
        // 0 when noise = _NoiseCutoffThreshold (and below), and 1 when noise = 1
        float noiseScale = LerpStep(_NoiseCutoffThreshold, 1, noise);
        float scaleInterpolant = lerp(noiseScale, random3, _ScaleRandomness);
        float3 scale = lerp(_MinScale, _MaxScale, scaleInterpolant);
        
        float3 worldPos = mul(_ObjectToWorldMatrix, float4(localPos, 1)).xyz;
        
        // Altitude based calculations
        float altitude = length(worldPos - _PlanetOrigin) - _PlanetRadius;
        float altitudeScalar = GetAltitudeScalar(altitude, worldPos);
        
        // If we're placing all scatters at the same altitude
        // For anything altitude related we need to be working in world space, so we introduce a slight inefficiency
        // by requiring a conversion back into local space for the final position
        if (_DistributeFixedAltitude == 1)
        {
            float altitudeDiff = altitude - _FixedAltitude;
            worldPos -= (_PlanetNormal * altitudeDiff);
            localPos = mul(_WorldToObjectMatrix, float4(worldPos, 1)).xyz;
        }
        
        // Cannot spawn if:
        // 1. Failed spawn chance probability check
        // 2. Is out of altitude range (close to altitude range, lower the spawn chance)
        // 3. Is on a slope (higher gradient, lower spawn chance)
        // 4. Noise is past cutoff threshold
        bool canSpawn = (random4 < _SpawnChance * altitudeScalar * slope * vertexAllowScatter) && (noise > _NoiseCutoffThreshold);
        
        newObject.localPos = localPos;
        newObject.localScale = scale;
        newObject.rotation = random5 * 180.0f;
        newObject.index = id.x * 3;
    
        if (canSpawn)
        {
            output.Append(newObject);
        }
    }
}

//
//  Evaluation Compute Shader
//

// Transforms local positions to world positions

StructuredBuffer<PositionData> positions;
AppendStructuredBuffer<TransformData> instancingDataLOD0;
AppendStructuredBuffer<TransformData> instancingDataLOD1;
AppendStructuredBuffer<TransformData> instancingDataLOD2;
StructuredBuffer<uint> objectLimits;

[numthreads(32, 1, 1)]
void Evaluate(uint3 id : SV_DispatchThreadID)
{
    if (id.x > objectLimits[0] - 1)
    {
        return;
    }

    PositionData pos = positions[id.x];

    float3 worldPos = mul(_ObjectToWorldMatrix, float4(pos.localPos, 1)).xyz;
    
    // Get distances to frustum faces
    float4 cd0 = CameraDistances0(worldPos);
    float4 cd1 = CameraDistances1(worldPos);
    
	// Get distance from camera to object
    float lodDist = distance(_WorldSpaceCameraPosition, worldPos) / _MaxRange; //Percentage to max range
    
    
    if (lodDist > 1)
    {
        return;
    }
    if (!(all(cd0 >= _CullLimit) && all(cd1 >= _CullLimit)) && lodDist > _CullRadius)
    {
        return;
    }
    
    bool fadeRangeCull = IsOutOfRangeEarly(lodDist, pos.localPos);
    if (fadeRangeCull)
    {
        return;
    }
    
    // Get triangle indices for sampling vertices
    
    uint index1 = triangles[pos.index];
    uint index2 = triangles[pos.index + 1];
    uint index3 = triangles[pos.index + 2];

    // Calculating the average normal using (nrm1 + nrm2 + nrm3) / 3 does not give face normal, so compute face normal from vertex positions

    float3 vert1 = vertices[index1];
    float3 vert2 = vertices[index2];    
    float3 vert3 = vertices[index3];

    // Get the terrain normal in world space
    float3 avgNormal = normalize(cross(vert2 - vert1, vert3 - vert1));
    avgNormal = mul(_ObjectToWorldMatrix, float4(avgNormal, 0)).xyz;
    
    // the float3 at the end becomes the terrain average normal
    float4x4 mat = GetTRSMatrix(worldPos, float3(0, pos.rotation, 0), pos.localScale, avgNormal);

    TransformData object;
    object.objectToWorld = mat;

    if (lodDist > _Lod12Split)
    {
        instancingDataLOD2.Append(object);
        return;
    }
    else if (lodDist > _Lod01Split)
    {
        instancingDataLOD1.Append(object);
        return;
    }
    else
    {
        instancingDataLOD0.Append(object);
    }
}
