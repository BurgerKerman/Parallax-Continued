#pragma kernel Distribute
#pragma kernel Evaluate

#include "ScatterStructs.cginc"
#include "ScatterParams.cginc"
#include "ScatterUtils.cginc"
#include "SimplexNoise.cginc"

StructuredBuffer<float3> vertices;
StructuredBuffer<float3> normals;
StructuredBuffer<int> triangles;

AppendStructuredBuffer<PositionData> output;

//
//  Distribution Compute Shader
//

// Runs per triangle in the mesh (indices count / 3)

[numthreads(32,1,1)]
void Distribute (uint3 id : SV_DispatchThreadID)
{
    // Early return if max triangles to be processed is exceeded
    if (((int)id.x * _PopulationMultiplier) > _MaxCount - 1)
    {
        return;
    }
    
    // Get the indices for the vertices of this thread's triangle
    uint index1 = triangles[id.x * 3];
    uint index2 = triangles[id.x * 3 + 1];
    uint index3 = triangles[id.x * 3 + 2];
    
    // Get triangle vertices
    float3 v1 = vertices[index1];
    float3 v2 = vertices[index2];
    float3 v3 = vertices[index3];
    
    // Get triangle normals
    float3 n1 = normals[index1];
    float3 n2 = normals[index2];
    float3 n3 = normals[index3];
    
    // Use tri center as the random seed, since it will vary per quad
    // but will remain persistent
    float3 center = TriCenter(v1, v2, v3);
    
    // Create an object on this triangle for every population multiplier
    for (int i = 0; i < _PopulationMultiplier; i++)
    {
        // Output struct
        PositionData newObject;
        
        // Use the local vertex position as a random input so each quad is different
        // X must be sqrtd
        float randomX = sqrt(Rand(center + i));
        float randomY = Rand(center * 0.5 + i);
        float3 localPos = RandomPoint(v1, v2, v3, randomX, randomY);
        
        bool canSpawn = Rand(localPos) < _SpawnChance;
        
        float noiseValue = snoise(localPos * _NoiseScale) * 0.5f + 0.5f;
        float heightMultiplier = lerp(0.5, 2, noiseValue);
        
        newObject.localPos = localPos;
        newObject.localScale = float3(1.1, 1.1, 1.1);
        newObject.rotation = Rand(center * 0.25 + i) * 180.0f;
        newObject.index = id.x * 3;
    
        if (canSpawn)
        {
            output.Append(newObject);
        }
    }
}

//
//  Evaluation Compute Shader
//

// Transforms local positions to world positions

StructuredBuffer<PositionData> positions;
AppendStructuredBuffer<TransformData> instancingData;
StructuredBuffer<uint> objectLimits;

[numthreads(32, 1, 1)]
void Evaluate(uint3 id : SV_DispatchThreadID)
{
    if (id.x > objectLimits[0] - 1)
    {
        return;
    }

    PositionData pos = positions[id.x];

    float3 worldPos = mul(_ObjectToWorldMatrix, float4(pos.localPos, 1)).xyz;
    
    // Get distances to frustum faces
    float4 cd0 = CameraDistances0(worldPos);
    float4 cd1 = CameraDistances1(worldPos);
    
	// Get distance from camera to object
    float lodDist = distance(_WorldSpaceCameraPosition, worldPos) / _MaxRange; //Percentage to max range

    if (lodDist > 1)
    {
        return;
    }
    if (!(all(cd0 >= 0) && all(cd1 >= 0)))
    {
        return;
    }
    
    // the float3 at the end becomes the terrain average normal
    float4x4 mat = GetTRSMatrix(worldPos, float3(0, pos.rotation, 0), pos.localScale, float3(0, 1, 0));

    TransformData object;
    object.objectToWorld = mat;

    instancingData.Append(object);
}